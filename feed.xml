<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://binbyz.github.io//blog/feed.xml" rel="self" type="application/atom+xml" /><link href="https://binbyz.github.io//blog/" rel="alternate" type="text/html" hreflang="ko" /><updated>2024-03-01T11:15:34+00:00</updated><id>https://binbyz.github.io//blog/feed.xml</id><title type="html">byzz’s programming note</title><subtitle>비즈 개발 노트</subtitle><entry><title type="html">Expo, 프로젝트 생성부터 초기 세팅</title><link href="https://binbyz.github.io//blog/expo/2024/03/01/expo-init.html" rel="alternate" type="text/html" title="Expo, 프로젝트 생성부터 초기 세팅" /><published>2024-03-01T11:14:00+00:00</published><updated>2024-03-01T11:14:00+00:00</updated><id>https://binbyz.github.io//blog/expo/2024/03/01/expo-init</id><content type="html" xml:base="https://binbyz.github.io//blog/expo/2024/03/01/expo-init.html"><![CDATA[<h2 id="expo-초기-프로젝트-생성하기">Expo 초기 프로젝트 생성하기</h2>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npx create-expo-app ProjectName
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">npx</code>는 로컬에 설치되어 있지 않은 npm 패키지를 실행할 수 있게 도와준다.(로컬에 <code class="language-plaintext highlighter-rouge">$ npm install</code>을 통해 설치하지 않아도 실행이 가능하다는 의미) 자동으로 설치되고 삭제됨으로 항상 최신 버전의 패키지로 명령어를 실행할 수 있게한다. 이를 <code class="language-plaintext highlighter-rouge">npx</code> 없이 실행하려면 <code class="language-plaintext highlighter-rouge">$ npm install -g create-expo-app</code> 명령어로 기본 로컬 환경에 글로벌로 설치하고 실행할 수 있지만, 빠르게 변하는 생태계 속에서 <code class="language-plaintext highlighter-rouge">npx</code>는 최고의 선택이 될 수 있다.</p>

<h2 id="typescript-적용하기">TypeScript 적용하기</h2>

<p><code class="language-plaintext highlighter-rouge">$ npx create-expo-app ProjectName</code>으로 생성된 프로젝트 파일은 기본적으로 <code class="language-plaintext highlighter-rouge">.js</code> 파일로 생성된다. <strong>TypeScript</strong>를 적용시키는 방법을 따라해보자.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npm <span class="nb">install</span> <span class="nt">--save-dev</span> typescript @types/react @types/react-native @types/react-dom
</code></pre></div></div>

<ul>
  <li><strong>babel</strong>: Babel은 자바스크립트 코드를 변환하는 툴체인(toolchain)이다. 주로 최신 버전의 JavaScript(ES6 이상) 코드를 이전 버전의 JavaScript(ES5)로 변환하여, 아직 최신 JavaScript 문법을 지원하지 않는 오래된 브라우저나 환경에서도 코드가 실행될 수 있게 해준다. (웹 기준)</li>
</ul>

<h3 id="typescript-설정-파일-생성">TypeScript 설정 파일 생성</h3>

<p>프로젝트의 루트 디렉토리에 <code class="language-plaintext highlighter-rouge">tsconfig.json</code> 파일을 생성하고 아래 내용을 붙여 넣어준다. (이미 파일이 존재하면 그것을 사용) 해당 파일은 TypeScript 컴파일러에게 프로젝트를 어떻게 컴파일할지 알려준다.</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"compilerOptions"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"allowJs"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w">
    </span><span class="nl">"allowSyntheticDefaultImports"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w">
    </span><span class="nl">"esModuleInterop"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w">
    </span><span class="nl">"isolatedModules"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w">
    </span><span class="nl">"jsx"</span><span class="p">:</span><span class="w"> </span><span class="s2">"react-native"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"lib"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">"dom"</span><span class="p">,</span><span class="w"> </span><span class="s2">"esnext"</span><span class="p">],</span><span class="w">
    </span><span class="nl">"moduleResolution"</span><span class="p">:</span><span class="w"> </span><span class="s2">"node"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"noEmit"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w">
    </span><span class="nl">"strict"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w">
    </span><span class="nl">"target"</span><span class="p">:</span><span class="w"> </span><span class="s2">"esnext"</span><span class="w">
  </span><span class="p">},</span><span class="w">
  </span><span class="nl">"exclude"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">"node_modules"</span><span class="p">,</span><span class="w"> </span><span class="s2">"babel.config.js"</span><span class="p">,</span><span class="w"> </span><span class="s2">"metro.config.js"</span><span class="p">,</span><span class="w"> </span><span class="s2">"jest.config.js"</span><span class="p">]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<h3 id="파일-확장자-변경하기">파일 확장자 변경하기</h3>

<p>처음 프로젝트를 생성하면 <code class="language-plaintext highlighter-rouge">.js</code> 파일 확장자로 파일이 생성돼 있기 때문에 <code class="language-plaintext highlighter-rouge">.ts</code> 또는 <code class="language-plaintext highlighter-rouge">.tsx</code> 파일 확장자로 변경해준다.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">.ts</code>: React 컴포넌트가 없는 순수 TypeScript 파일</li>
  <li><code class="language-plaintext highlighter-rouge">.tsx</code>: React 컴포넌트가 있는 경우</li>
</ul>

<h2 id="자동-코드포맷터-적용하기">자동 코드포맷터 적용하기</h2>

<p>일관된 컨벤션을 유지하기 위해 <strong>Prettier</strong>를 사용해보자. 세미콜론 추가, 코드 줄바꿈, 단일 인용부호와 이중 인용부호 간 전환 등을 자동으로 처리해준다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npm <span class="nb">install</span> <span class="nt">--save-dev</span> prettier
</code></pre></div></div>

<h3 id="prettier-설정-파일-생성">Prettier 설정 파일 생성</h3>

<p>루트 디렉토리에 <code class="language-plaintext highlighter-rouge">.prettierrc</code> 파일을 생성하고 아래의 파일 내용을 넣어주자.</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"semi"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w">
  </span><span class="nl">"singleQuote"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>입 맛에 맞게 커스텀 할 수 있고, 사용중인 IDE(PHPStorm, VSCode)에서 파일 저장시 <strong>Prettier</strong>가 자동으로 실행되게 할 수 있다. 이 내용은 따로 추가하지 않겠음.</p>

<h2 id="코드-품질-도구-적용하기">코드 품질 도구 적용하기</h2>

<p><strong>ESLint</strong>는 코드에서 발견된 패턴을 식별하여 문제를 보고해준다. A라는 코드를 B라는 코드로 변경할 수 있다면 그 부분을 IDE를 통해서 알 수 있다. (당연히 B코드의 품질이 더 좋은 코드를 추천해준다)</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npm <span class="nb">install</span> <span class="nt">--save-dev</span> eslint @typescript-eslint/parser @typescript-eslint/eslint-plugin
</code></pre></div></div>

<p>루트 디렉토리에 <code class="language-plaintext highlighter-rouge">.eslintrc</code> 파일을 생성해고 아래의 내용을 넣어준다.</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"parser"</span><span class="p">:</span><span class="w"> </span><span class="s2">"@typescript-eslint/parser"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"extends"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
    </span><span class="s2">"plugin:@typescript-eslint/recommended"</span><span class="w">
  </span><span class="p">],</span><span class="w">
  </span><span class="nl">"plugins"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
    </span><span class="s2">"@typescript-eslint"</span><span class="w">
  </span><span class="p">],</span><span class="w">
  </span><span class="nl">"rules"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"semi"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">"error"</span><span class="p">,</span><span class="w"> </span><span class="s2">"always"</span><span class="p">],</span><span class="w">
    </span><span class="nl">"quotes"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">"error"</span><span class="p">,</span><span class="w"> </span><span class="s2">"single"</span><span class="p">]</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<h2 id="절대-경로로-컴포넌트-import-하기">절대 경로로 컴포넌트 import 하기</h2>

<p>React 컴포넌트를 작성하다보면 <code class="language-plaintext highlighter-rouge">import Comp from '../components/Comp</code>와 같은 import 구문이 작성된다. 보기도 싫고 유지보수도 귀찮아진다. 이 부분을 절대경로로(예; <code class="language-plaintext highlighter-rouge">import Comp from @/components/Comp</code>) 변경해보자.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npm <span class="nb">install</span> <span class="nt">--save-dev</span> babel-plugin-module-resolver
</code></pre></div></div>

<p>루트 디렉토리에 존재하는 <code class="language-plaintext highlighter-rouge">babel.config.js</code> 파일을 열고 다음과 같이 수정해주자.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nf">function </span><span class="p">(</span><span class="nx">api</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">api</span><span class="p">.</span><span class="nf">cache</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>

  <span class="k">return</span> <span class="p">{</span>
    <span class="na">presets</span><span class="p">:</span> <span class="p">[</span><span class="dl">'</span><span class="s1">babel-preset-expo</span><span class="dl">'</span><span class="p">],</span>
    <span class="na">plugins</span><span class="p">:</span> <span class="p">[</span>
      <span class="p">[</span>
        <span class="dl">'</span><span class="s1">module-resolver</span><span class="dl">'</span><span class="p">,</span>
        <span class="p">{</span>
          <span class="na">root</span><span class="p">:</span> <span class="p">[</span><span class="dl">'</span><span class="s1">./</span><span class="dl">'</span><span class="p">],</span>
          <span class="na">alias</span><span class="p">:</span> <span class="p">{</span>
            <span class="dl">'</span><span class="s1">@</span><span class="dl">'</span><span class="p">:</span> <span class="dl">'</span><span class="s1">./src</span><span class="dl">'</span><span class="p">,</span>
          <span class="p">},</span>
        <span class="p">},</span>
      <span class="p">],</span>
    <span class="p">],</span>
  <span class="p">};</span>
<span class="p">};</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">return</code> 구문에 <code class="language-plaintext highlighter-rouge">plugins</code> 속성이 추가되었다. 그리고 이를 <strong>Typescript</strong>가 컴파일에 활용할 수 있게 <code class="language-plaintext highlighter-rouge">tsconfig.json</code> 파일을 열고 아래 내용을 참조하여 <code class="language-plaintext highlighter-rouge">paths</code> 속성을 추가하자.</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"compilerOptions"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"baseUrl"</span><span class="p">:</span><span class="w"> </span><span class="s2">"."</span><span class="p">,</span><span class="w">
    </span><span class="nl">"paths"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
      </span><span class="nl">"@/*"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">"src/*"</span><span class="p">]</span><span class="w">
    </span><span class="p">}</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<h2 id="정리">정리</h2>

<p>이렇게 하면 기본적으로 프로젝트를 진행하는 동안 유용한 패키지들이 설치되었다. <strong>Prettier</strong>나 <strong>ESLint</strong> 같은 경우는 반드시 IDE에 설정을 통하여 파일이 저장될때 <strong>실행</strong>되게 세팅해 놓아야 유용하다.</p>]]></content><author><name></name></author><category term="Expo" /><summary type="html"><![CDATA[Expo 초기 프로젝트 생성하기]]></summary></entry><entry><title type="html">프롬프트 엔지니어링 작성하기</title><link href="https://binbyz.github.io//blog/ai/2024/02/21/prompt-engineering.html" rel="alternate" type="text/html" title="프롬프트 엔지니어링 작성하기" /><published>2024-02-21T10:39:00+00:00</published><updated>2024-02-21T10:39:00+00:00</updated><id>https://binbyz.github.io//blog/ai/2024/02/21/prompt-engineering</id><content type="html" xml:base="https://binbyz.github.io//blog/ai/2024/02/21/prompt-engineering.html"><![CDATA[<h2 id="개요">개요</h2>

<p>요즘 프롬프트 엔지니어링(Prompt Engineering)이라는 단어가 많이 보인다. LLM(Large Language Model)들이 우후죽순으로 생성되면서 프롬프트 작성능력이 그 만큼 중요하게 대두되고 있는 이유이다. LLM 모델들은 대게 사람이 만들어 놓고 인터넷에 게시된 자료들을 기반으로 학습된다. 그 이유에서 같은 주제에 내용이라 하더라도 더 깊이 있는 정보가 있는 자료가 있는 반면에 그렇지 않은 자료들과 결합해서 LLM 모델들이 데이터를 정제하여 사용자가 원하는 자료들을 잘 가공하여 보여주어야 한다. 이 모든 것에 해답은 프롬프트에 있다는 얘기가 된다.</p>

<p>많은 프롬프트 엔지니어링 영상과 글들을 보았고, 그 자료들은 결국엔 중복된 내용들에 대해서 다루고 있어 이에 대해 한 번 정리해 놓고자 글을 작성한다.</p>

<h2 id="역할-정하기페르소나-persona">역할 정하기(페르소나, Persona)</h2>

<p>가장 기본이다. 많은 자료들이 페르소나라는 단어로 내용을 소개해준다. 원리는 간단하다. LLM 모델에 내 질문에 어떤 주제에 맞춰 답변을 해주어야 하는지 주제를 제한시켜주는 것이다. 거기에 특정 분야에 “전문가”라는 단어를 투영시켜 LLM 모델이 수 많은 학습된 데이터에서 조금 더 특화된 데이를 찾아 답변을 해줄 수 있도록 제한한다. 예를 들면 다음과 같다.</p>

<h3 id="페르소나-예시">페르소나 예시</h3>

<ul>
  <li>너는 라라벨(Laravel) 프레임워크에 통달한 전문 개발자야.</li>
  <li>너는 유럽 여행 전문 가이드야.</li>
  <li>너는 수 많은 히트곡을 작성한 작곡가야.</li>
</ul>

<p>이렇게 페르소나를 설정해 줌으로써 수 많은 학습된 데이터 카테고리에서 특정 카테고리로 데이터의 범위를 완전히 좁혀준다.</p>

<h2 id="예시-넣어주기few-shot-zero-shot">예시 넣어주기(Few Shot, Zero Shot)</h2>

<p>두 번째는 LLM 모델이 어떻게 답변을 해주어야 하는지 항상 예시를 넣어주어야 한다. 여기서 Few-Shot은 2가지 이상의 예시를 프로픔트에 작성해 줌으로써 LLM 모델이 더 쉽게 이해도록 돕는 것이고, Zero-shot은 한 가지의 예시문만 넣어준다는 뜻이된다. 바로 쉽게 바로 예시를 가보자.</p>

<h3 id="zero-shot-예시">Zero-Shot 예시</h3>

<blockquote>
  <p>다음의 예시처럼 답변해줘.</p>

  <p>Q. 웹 개발자가 되기 위해서는 어떤 단계들을 거치면서 학습을 해야하는지 학습 가이드라인을 만들어줘.
A. 다음은 웹 개발자가 되기 위한 학습가이드 라인입니다.</p>
  <ol>
    <li>HTML 마크업 배우기</li>
    <li>스크립트 언어 택하여 배우기</li>
    <li>Database 배우기</li>
  </ol>
</blockquote>

<p>이 처럼 받고 싶은 형태의 답변을 예시로 작성하여 프롬프트로 제공해 줌으로써 조금 더 규격화된 답변을 받을 수 있다. 실제 예시에 <code class="language-plaintext highlighter-rouge">JSON</code> 포맷으로 예시로 보여주고 프롬프트 예시를 알려주면 답변은 <code class="language-plaintext highlighter-rouge">JSON</code> 형태로 나오게된다.</p>

<h2 id="의미있는-예시를-작성하기추론-시키기">의미있는 예시를 작성하기(추론 시키기)</h2>

<p>예시를 작성한다고 하더라도 실제로 실생활 또는 사실 내용 기반으로 질문과 답변을 프롬프트에 입력해주어야 LLM 모델이 그 의미를 파악하고 이 후의 답변도 직접 추론과정을 거치며 조금 더 명확한 답을 제공해 줄 수 있다. 예시를 너무 간단하게 작성하지 말라는 얘기가 된다.</p>

<p>예를 들면, 위의 Zero-Shot 예시 답변에 살을 더 붙이는 것이다. 위에는 단순히 1, 2, 3번으로 나열만 되어 있는데 그 옆에 1번으로 HTML 마크업을 배우라고 한 이유에 대해서 작성해주자. 다음과 같다.</p>

<h3 id="추론-예시">추론 예시</h3>

<blockquote>
  <p>다음의 예시처럼 답변해줘.</p>

  <p>Q. 웹 개발자가 되기 위해서는 어떤 단계들을 거치면서 학습을 해야하는지 학습 가이드라인을 만들어줘.
A. 다음은 웹 개발자가 되기 위한 학습가이드 라인입니다.</p>
  <ol>
    <li>HTML 마크업 배우기
      <ul>
        <li>HTML은 모든 웹 페이지의 뼈대를 이루는 기본입니다. 모든 웹 페이지는 결국엔 HTML로 구성되기 때문에 가장 먼저 학습하는 것이 좋습니다.</li>
      </ul>
    </li>
    <li>스크립트 언어 택하여 배우기
      <ul>
        <li>컴파일 언어보다 보다 쉽게 배움에 접근할 수 있습니다. … 이후에 내가 원하는 기술 스택을 선택 후 기술을 변경해도 충분합니다.</li>
      </ul>
    </li>
    <li>Database 배우기</li>
  </ol>
</blockquote>

<p>이런식으로 예시에 살을 붙여주고 LLM 모델이 조금 더 의미있고 추론 가능한 답변을 할 수 있도록 프롬프트를 작성한다.</p>

<h2 id="보상하기">보상하기</h2>

<p>사실 이 부분이 아직까지 나에겐 가장 의아한 부분이긴 하다. 모든 질문은 의미가 있고 질문자에게는 절실하다는 기본 가정이 되어야 하는데 프롬프트 마지막에 “이 질문은 나에게 가장 중요하니깐 너를 통해 해당 문제가 해결되면 소정의 금액을 보상해 줄게”와 같은 보상형식의 문장을 꼭 넣으라고들 추천한다. 그래야 실제 LLM 모델을 작동시킬 때 조금이라도 더 양질의 데이터를 찾아 답변할 수 있게 의미를 전달시키는 행위가 된다고 한다. 가령 내가 직접본 프롬프트 관련 영상들은 아래의 문장들을 마지막에 넣길 조언하고 있다.</p>

<h3 id="보상-예시">보상 예시</h3>

<ul>
  <li>“Let’s think step by step”</li>
  <li>“I’ll pay you $500”</li>
</ul>

<h2 id="정리">정리</h2>

<p>아직까지 수 많은 데이터를 학습한 LLM 모델이 정확하고 좋은 양질의 데이터를 출력할 수 있는지 프롬프트 관련 연구는 계속 진행 중이라고 한다. 결국 프롬프트 기반으로 LLM이 데이터를 찾는 것이니 만큼 양질의 프롬프트를 작성하는 것이 좋은 정보를 빨리 찾는 행위가 될 것이다.</p>

<p>기본적인 뼈대(페르소나, 예시, 보상하기)는 갖추고 그에 맞게 우리가 커뮤니티의 내가 궁금한 정보에 대해서 질문을 해봤던 경험들을 토대로 상대방이 조금 더 이해하기 쉽게 의미있는 프롬프트 작성이 가장 중요하다고 생각이 든다.</p>]]></content><author><name></name></author><category term="AI" /><summary type="html"><![CDATA[개요]]></summary></entry><entry><title type="html">cURL, MessagePack 바이너리 전송하기</title><link href="https://binbyz.github.io//blog/laravel/2024/02/18/msgpack.html" rel="alternate" type="text/html" title="cURL, MessagePack 바이너리 전송하기" /><published>2024-02-18T10:11:00+00:00</published><updated>2024-02-18T10:11:00+00:00</updated><id>https://binbyz.github.io//blog/laravel/2024/02/18/msgpack</id><content type="html" xml:base="https://binbyz.github.io//blog/laravel/2024/02/18/msgpack.html"><![CDATA[<h2 id="개요">개요</h2>

<p>라라벨 애플리케이션에서 <code class="language-plaintext highlighter-rouge">curl</code>를 통해 대량의 <code class="language-plaintext highlighter-rouge">json_encode</code>된 데이터를 전송하는 케이스가 있었다. 객체나 배열 자체를 클라이언트에서 Inspect 할 수 있는 오픈소스 라이브러리(<a href="https://phpgg.kr/">phpgg.kr</a>)인데 가령 객체 자체차 크거나 여러개의 객체가 중첩된 경우 메모리 할당량을 초과하여 발생하는 문제였다. 라라벨의 <code class="language-plaintext highlighter-rouge">dump()</code>, <code class="language-plaintext highlighter-rouge">dd()</code> 헬퍼 함수들은 이런 문제를 해결하기 위해 중첩된 객체의 사이즈가 너무 크면 잘라서 무효화 시키는 방법으로 데이터를 보여주었다. 나는 최대한 있는 그대로 내가 보고싶은 데이터를 잘림 없이 보여주고 싶었다.</p>

<h2 id="해결책">해결책</h2>

<p><code class="language-plaintext highlighter-rouge">json_encode</code>를 통해 데이터를 전송하는게 가장 큰 비용이 발생하여 이를 압축된 바이너리(binary) 데이터로 전송하고자 한다. 바이너리로 전송하는 방법으로는 가장 쉽게 접근할 수 있는 방법으로 아래 두 가지가있다.</p>

<ol>
  <li><strong>Protocol Buffers</strong>
    <ul>
      <li>Protocol Buffer(Protobuf)는 구글에서 개발한 언어 중립적이고 플랫폼 독립적인 데이터 직렬화 도구이지만, 학습 곡선이 어느정도 존재한다. 장점으로는 <code class="language-plaintext highlighter-rouge">.proto</code> 파일을 통해 구조를 정의하면 이를 다양한 프로그래밍 언어로 변환할 수 있는 코드를 자동으로 생성할 수 있다.</li>
    </ul>
  </li>
  <li><strong>Message Pack</strong>
    <ul>
      <li>MessagePack 포맷은 JSON과 유사한 스키마리스(schema-less) 데이터 교환 포맷이지만, 이진 형식을 사용하기 때문에 텍스트 기반의 JSON 보다 크기가 작고 처리 속도가 빠르다는 특징을 가지고 있다.</li>
    </ul>
  </li>
</ol>

<p>두 가지 방법 중 쉽고 빠르게 적용가능한 <strong>MessagePack</strong>을 통해 압축된 바이너리 데이터를 적용해보자.</p>

<h2 id="messagepack-적용">MessagePack 적용</h2>

<h3 id="의존성-설치">의존성 설치</h3>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>composer require rybakit/msgpack
</code></pre></div></div>

<p>먼저 MessagePack 압축 알고리즘을 사용하기 위해 아래의 라이브러리를 추가한다. 해당 라이브러리는 php 모듈이 따로 설치돼 있지 않아도 소스단에서 사용할 수 있게 구현된 라이브러리이다. (물론 직접 php 모듈을 통해 설치하면 퍼포먼스가 더 상승할 것이다)</p>

<h3 id="코드-적용">코드 적용</h3>

<p>나는 http <code class="language-plaintext highlighter-rouge">curl</code>를 통해 바이너리 데이터를 전송할 생각이기 때문에 아래의 코드와 같이 <code class="language-plaintext highlighter-rouge">CURLOPT_HTTPHEADER</code>를 <code class="language-plaintext highlighter-rouge">application/x-msgpack</code>으로 수정해 주었고, <code class="language-plaintext highlighter-rouge">MessagePack::pack($cunk);</code> 코드를 통해 인코딩을 간단히 진행한다.</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?php</span>

<span class="kn">namespace</span> <span class="nn">Beaverlabs\Gg</span><span class="p">;</span>

<span class="kn">use</span> <span class="nc">Rybakit\MessagePack\MessagePack</span><span class="p">;</span>

<span class="kd">class</span> <span class="nc">Gg</span>
<span class="p">{</span>
    <span class="c1">// 기존 메서드와 프로퍼티는 유지</span>

    <span class="k">private</span> <span class="k">function</span> <span class="n">sendData</span><span class="p">():</span> <span class="kt">void</span>
    <span class="p">{</span>
        <span class="nv">$endpoint</span> <span class="o">=</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="nf">getEndpoint</span><span class="p">();</span>

        <span class="nv">$ch</span> <span class="o">=</span> <span class="nb">curl_init</span><span class="p">();</span>
        <span class="nb">curl_setopt</span><span class="p">(</span><span class="nv">$ch</span><span class="p">,</span> <span class="no">CURLOPT_URL</span><span class="p">,</span> <span class="nv">$endpoint</span><span class="p">);</span>
        <span class="nb">curl_setopt</span><span class="p">(</span><span class="nv">$ch</span><span class="p">,</span> <span class="no">CURLOPT_RETURNTRANSFER</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
        <span class="nb">curl_setopt</span><span class="p">(</span><span class="nv">$ch</span><span class="p">,</span> <span class="no">CURLOPT_CONNECTTIMEOUT_MS</span><span class="p">,</span> <span class="mi">1000</span><span class="p">);</span>
        <span class="nb">curl_setopt</span><span class="p">(</span><span class="nv">$ch</span><span class="p">,</span> <span class="no">CURLOPT_TIMEOUT_MS</span><span class="p">,</span> <span class="mi">1000</span><span class="p">);</span>
        <span class="nb">curl_setopt</span><span class="p">(</span><span class="nv">$ch</span><span class="p">,</span> <span class="no">CURLOPT_USERAGENT</span><span class="p">,</span> <span class="k">self</span><span class="o">::</span><span class="nv">$userAgent</span><span class="p">);</span>
        <span class="c1">// MessagePack 컨텐츠 타입 설정</span>
        <span class="nb">curl_setopt</span><span class="p">(</span><span class="nv">$ch</span><span class="p">,</span> <span class="no">CURLOPT_HTTPHEADER</span><span class="p">,</span> <span class="p">[</span><span class="s1">'Content-Type: application/x-msgpack'</span><span class="p">]);</span>
        <span class="nb">curl_setopt</span><span class="p">(</span><span class="nv">$ch</span><span class="p">,</span> <span class="no">CURLOPT_POST</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
        <span class="nb">curl_setopt</span><span class="p">(</span><span class="nv">$ch</span><span class="p">,</span> <span class="no">CURLOPT_SSL_VERIFYHOST</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
        <span class="nb">curl_setopt</span><span class="p">(</span><span class="nv">$ch</span><span class="p">,</span> <span class="no">CURLOPT_SSL_VERIFYPEER</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>

        <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="k">empty</span><span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">))</span> <span class="p">{</span>
            <span class="nv">$chunk</span> <span class="o">=</span> <span class="nb">array_splice</span><span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">self</span><span class="o">::</span><span class="no">BUFFER_CHUNK_SIZE</span><span class="p">);</span>
            <span class="c1">// 데이터를 MessagePack 형식으로 인코딩</span>
            <span class="nv">$encodedData</span> <span class="o">=</span> <span class="nc">MessagePack</span><span class="o">::</span><span class="nb">pack</span><span class="p">(</span><span class="nv">$chunk</span><span class="p">);</span>
            <span class="nb">curl_setopt</span><span class="p">(</span><span class="nv">$ch</span><span class="p">,</span> <span class="no">CURLOPT_POSTFIELDS</span><span class="p">,</span> <span class="nv">$encodedData</span><span class="p">);</span>
            <span class="nb">curl_exec</span><span class="p">(</span><span class="nv">$ch</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="nb">curl_close</span><span class="p">(</span><span class="nv">$ch</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p><a href="https://github.com/binbyz/gg/blob/03fc1664e5f1831d6c70e45250ed61ff780cc43f/src/Gg.php#L147">전체 소스 보기</a></p>

<h3 id="데이터-받기클라이언트">데이터 받기(클라이언트)</h3>

<p>클라이언트는 <strong>electron</strong>으로 작성돼 있고, http 서버로는 <strong>express</strong>를 사용 중이였다. 클라이언트에서도 <strong>MessagePack</strong>으로 인코딩된 데이터를 받아 디코딩을 진행하기 위해 아래의 추가적인 의존성을 설치하고,</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npm <span class="nb">install</span> @msgpack/msgpack
</code></pre></div></div>

<p>미들웨어단에서 아래와 같은 헤더타입을 정의해준다.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// MessagePack 데이터를 위한 미들웨어 설정</span>
<span class="nx">app</span><span class="p">.</span><span class="nf">use</span><span class="p">(</span><span class="nx">express</span><span class="p">.</span><span class="nf">raw</span><span class="p">({</span> <span class="na">type</span><span class="p">:</span> <span class="dl">'</span><span class="s1">application/x-msgpack</span><span class="dl">'</span><span class="p">,</span> <span class="na">limit</span><span class="p">:</span> <span class="dl">'</span><span class="s1">128mb</span><span class="dl">'</span> <span class="p">}));</span>
</code></pre></div></div>

<p>그리고 데이터를 받아 아래와 같이 디코딩을 진행한다.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="p">{</span> <span class="nx">decode</span> <span class="p">}</span> <span class="o">=</span> <span class="nf">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">@msgpack/msgpack</span><span class="dl">'</span><span class="p">);</span>

<span class="nx">app</span><span class="p">.</span><span class="nf">post</span><span class="p">(</span><span class="dl">'</span><span class="s1">/data</span><span class="dl">'</span><span class="p">,</span> <span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">try</span> <span class="p">{</span>
    <span class="c1">// MessagePack 데이터 디코딩</span>
    <span class="kd">const</span> <span class="nx">data</span> <span class="o">=</span> <span class="nf">decode</span><span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">body</span><span class="p">);</span>

    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
    <span class="nx">res</span><span class="p">.</span><span class="nf">send</span><span class="p">({</span> <span class="na">status</span><span class="p">:</span> <span class="dl">'</span><span class="s1">success</span><span class="dl">'</span><span class="p">,</span> <span class="na">message</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Data processed</span><span class="dl">'</span> <span class="p">});</span>
  <span class="p">}</span> <span class="k">catch </span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">error</span><span class="p">(</span><span class="dl">'</span><span class="s1">Decoding failed</span><span class="dl">'</span><span class="p">,</span> <span class="nx">error</span><span class="p">);</span>
    <span class="nx">res</span><span class="p">.</span><span class="nf">status</span><span class="p">(</span><span class="mi">500</span><span class="p">).</span><span class="nf">send</span><span class="p">({</span> <span class="na">status</span><span class="p">:</span> <span class="dl">'</span><span class="s1">error</span><span class="dl">'</span><span class="p">,</span> <span class="na">message</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Decoding failed</span><span class="dl">'</span> <span class="p">});</span>
  <span class="p">}</span>
<span class="p">});</span>
</code></pre></div></div>

<p>이렇게 하면 기존에 <code class="language-plaintext highlighter-rouge">json_encode</code>를 통해 전송 후 전달 받는 로직을 해치지 않고, 오히려 더 가볍고 빠르게 데이터를 전송할 수 있게 된다. 이것만으로 튜닝이 완벽하지 않을 수 있다. 이 후에도 동일한 문제가 발생된다면, 데이터를 더 쪼개어 <strong>분할 전송(Chunked Transfer)</strong>하거나 <strong>HTTP/2 서버 푸시</strong>를 사용하여 전송하는 방법도 고려해 볼 수 있다.</p>]]></content><author><name></name></author><category term="Laravel" /><summary type="html"><![CDATA[개요]]></summary></entry><entry><title type="html">클러스터 환경, Duplicate Entry Error 동시성 문제</title><link href="https://binbyz.github.io//blog/laravel/2024/02/14/duplicate-entry-error.html" rel="alternate" type="text/html" title="클러스터 환경, Duplicate Entry Error 동시성 문제" /><published>2024-02-14T04:00:00+00:00</published><updated>2024-02-14T04:00:00+00:00</updated><id>https://binbyz.github.io//blog/laravel/2024/02/14/duplicate-entry-error</id><content type="html" xml:base="https://binbyz.github.io//blog/laravel/2024/02/14/duplicate-entry-error.html"><![CDATA[<h2 id="개요-및-이슈">개요 및 이슈</h2>

<p>클러스터 환경에서 서비스를 운영하다 보면, <code class="language-plaintext highlighter-rouge">SQLSTATE[23000]: Integrity constraint violation: 1062 Duplicate entry '4240834-UKEY' for key 'database.table_name'(Connection: mysql, SQL ..)</code>와 같은 오류를 종종 마주칠 수 있습니다. 이유는 간단하다 동시에 많은 요청이 처리될 때, 특히 여러개의 Pod(클러스터 환경)에서 동시에 같은 데이터를 삽입(<code class="language-plaintext highlighter-rouge">INSERT</code>)하려고 할 때 발생할 수 있습니다. 기본적인 애플리케이션 내에서의 로직이 중복 삽입을 방지하기 위한 충분한 체크가 되지 않았거나 혹은 작성돼 있다고 하더라도 동시성 문제로 인해 충분히 발생할 수 있습니다.</p>

<h2 id="해결-방법">해결 방법</h2>

<ol>
  <li>오류 내용에서 알 수 있듯이 데이터베이스에 유니크 키 제약 조건을 설정합니다. 하지만 이것만으로는 애플리케이션의 동시성 문제를 해결할 수 없습니다.</li>
  <li>애플리케이션 코드내에서 중복체크 로직을 작성합니다. 라라벨로 예를들면 <code class="language-plaintext highlighter-rouge">Eloquent</code>의 <code class="language-plaintext highlighter-rouge">firstOrCreate</code> 또는 <code class="language-plaintext highlighter-rouge">updateOrCreate</code> 메소드를 사용하여, 중복 삽입을 시도하기 전에 해당 데이터가 존재하는지 체크할 수 있습니다. 이 방법은 단일 노드에서는 효과적이지만, 클러스터 환경에서는 여전히 <strong>경쟁 조건</strong>에 의해 문제가 발생할 수 있습니다.</li>
  <li>분산 락(Distributed Locking): 라라벨에서 제공하는 캐시 기반의 분산 락 매커니즘을 사용하여, 동시에 같은 작업을 수행하려는 요청들 사이에서 경쟁 조건을 방지할 수 있습니다. 예를 들어 가장 일반적은 Redis를 이용하여 락을 구현할 수 있습니다.</li>
</ol>

<h2 id="분산-락distributed-locking-예시">분산 락(Distributed Locking) 예시</h2>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">use</span> <span class="nc">Illuminate\Support\Facades\Cache</span><span class="p">;</span>

<span class="nv">$lock</span> <span class="o">=</span> <span class="nc">Cache</span><span class="o">::</span><span class="nf">lock</span><span class="p">(</span><span class="s1">'test_tracker_chance'</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span> <span class="c1">// 10초 동안 락을 얻으려고 시도</span>

<span class="k">if</span> <span class="p">(</span><span class="nv">$lock</span><span class="o">-&gt;</span><span class="nf">get</span><span class="p">())</span> <span class="p">{</span>
    <span class="c1">// 중복 체크 로직 실행</span>
    <span class="nv">$exists</span> <span class="o">=</span> <span class="no">DB</span><span class="o">::</span><span class="nf">table</span><span class="p">(</span><span class="s1">'test_trackers'</span><span class="p">)</span>
                <span class="o">-&gt;</span><span class="nf">where</span><span class="p">(</span><span class="s1">'member_id'</span><span class="p">,</span> <span class="nv">$memberId</span><span class="p">)</span>
                <span class="o">-&gt;</span><span class="nf">where</span><span class="p">(</span><span class="s1">'type'</span><span class="p">,</span> <span class="nv">$type</span><span class="p">)</span>
                <span class="o">-&gt;</span><span class="nf">exists</span><span class="p">();</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nv">$exists</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 데이터가 존재하지 않으면 삽입</span>
        <span class="no">DB</span><span class="o">::</span><span class="nf">table</span><span class="p">(</span><span class="s1">'test_trackers'</span><span class="p">)</span><span class="o">-&gt;</span><span class="nf">insert</span><span class="p">([</span>
            <span class="s1">'member_id'</span> <span class="o">=&gt;</span> <span class="nv">$memberId</span><span class="p">,</span>
            <span class="s1">'type'</span> <span class="o">=&gt;</span> <span class="nv">$type</span><span class="p">,</span>
            <span class="s1">'value'</span> <span class="o">=&gt;</span> <span class="nv">$value</span><span class="p">,</span>
            <span class="s1">'updated_at'</span> <span class="o">=&gt;</span> <span class="nf">now</span><span class="p">(),</span>
            <span class="s1">'created_at'</span> <span class="o">=&gt;</span> <span class="nf">now</span><span class="p">(),</span>
        <span class="p">]);</span>
    <span class="p">}</span>

    <span class="nv">$lock</span><span class="o">-&gt;</span><span class="nf">release</span><span class="p">();</span> <span class="c1">// 작업 완료 후 락 해제</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이 코드는 Redis 등의 분산 캐시를 사용하여 락을 구현한 예시입니다. <code class="language-plaintext highlighter-rouge">Cache::lock</code> 메소드를 사용하여 락을 얻고, 해당 락을 얻는데 성공하면 중복 데이터 삽입을 시조하기 전에 데이터가 이미 존재하는지 체크합니다. 모든 작업이 완료되면 <code class="language-plaintext highlighter-rouge">release</code> 메소드를 호출하여 락을 해제합니다.</p>

<h2 id="주의점">주의점</h2>

<p>위 코드에서는 다른 문제로 변질될 수 있습니다.</p>

<ol>
  <li>성능 영향: 락을 사용하면 리소스에 대한 접근이 순차적으로 이루어지기 때문에 고성능이 요구되는 환경에서는 요청 처리 시간에 영향을 줄 수 있습니다. 따라서 락을 사용해야하는 영역과 로직을 최소화하고, 가능한 한 빠르게 락을 해제하여 다른 요청이 대기 시간 없이 진행할 수 있도록 하는 것이 중요합니다.</li>
  <li>데드락(deadlock) 방지: 락을 사용할 때는 항상 데드락(deadlock)이 발생하지 않도록 주의해야 합니다. 데드락은 두 개 이상의 프로세스가 서로 다른 프로세스가 보유한 자원의 해제를 무한히 기다리는 교착 상태를 말합니다. 라라벨의 <code class="language-plaintext highlighter-rouge">Cache::lock</code> 메소드는 락을 얻지 못했을 때 예외를 발생시키거나, 설정한 시간이 지나면 자동으로 실채 처리되므로 데드락을 방지하는데 도움이 됩니다.</li>
</ol>

<h2 id="커넥션connection-분리">커넥션(connection) 분리</h2>

<p><code class="language-plaintext highlighter-rouge">Cache::lock</code>을 사용할 때 기존 애플리케이션에서 사용하는 커넥션과 별개로 분리하는게 도움이 될 수 있습니다. <code class="language-plaintext highlighter-rouge">config/cache.php</code> 파일에서 커넥션을 새롭게 정의하고 특정 캐시 연결을 <code class="language-plaintext highlighter-rouge">lockConnection</code>으로 사용하려면 <code class="language-plaintext highlighter-rouge">Cache::store('yourLockConnection')-&gt;lock(...)</code> 형식으로 사용할 수 있습니다.</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s1">'redis'</span> <span class="o">=&gt;</span> <span class="p">[</span>
    <span class="s1">'client'</span> <span class="o">=&gt;</span> <span class="s1">'predis'</span><span class="p">,</span>

    <span class="s1">'options'</span> <span class="o">=&gt;</span> <span class="p">[</span>
        <span class="s1">'cluster'</span> <span class="o">=&gt;</span> <span class="s1">'redis'</span><span class="p">,</span>
        <span class="s1">'prefix'</span> <span class="o">=&gt;</span> <span class="nf">env</span><span class="p">(</span><span class="s1">'REDIS_PREFIX'</span><span class="p">,</span> <span class="s1">'laravel_database_'</span><span class="p">),</span>
    <span class="p">],</span>

    <span class="s1">'default'</span> <span class="o">=&gt;</span> <span class="p">[</span>
        <span class="s1">'url'</span> <span class="o">=&gt;</span> <span class="nf">env</span><span class="p">(</span><span class="s1">'REDIS_URL'</span><span class="p">),</span>
        <span class="s1">'host'</span> <span class="o">=&gt;</span> <span class="nf">env</span><span class="p">(</span><span class="s1">'REDIS_HOST'</span><span class="p">,</span> <span class="s1">'127.0.0.1'</span><span class="p">),</span>
        <span class="s1">'password'</span> <span class="o">=&gt;</span> <span class="nf">env</span><span class="p">(</span><span class="s1">'REDIS_PASSWORD'</span><span class="p">,</span> <span class="kc">null</span><span class="p">),</span>
        <span class="s1">'port'</span> <span class="o">=&gt;</span> <span class="nf">env</span><span class="p">(</span><span class="s1">'REDIS_PORT'</span><span class="p">,</span> <span class="s1">'6379'</span><span class="p">),</span>
        <span class="s1">'database'</span> <span class="o">=&gt;</span> <span class="nf">env</span><span class="p">(</span><span class="s1">'REDIS_DB'</span><span class="p">,</span> <span class="s1">'0'</span><span class="p">),</span>
    <span class="p">],</span>

    <span class="c1">// 분산 락을 위한 별도의 연결 추가</span>
    <span class="s1">'lockConnection'</span> <span class="o">=&gt;</span> <span class="p">[</span>
        <span class="s1">'url'</span> <span class="o">=&gt;</span> <span class="nf">env</span><span class="p">(</span><span class="s1">'REDIS_URL'</span><span class="p">),</span>
        <span class="s1">'host'</span> <span class="o">=&gt;</span> <span class="nf">env</span><span class="p">(</span><span class="s1">'REDIS_HOST'</span><span class="p">,</span> <span class="s1">'127.0.0.1'</span><span class="p">),</span>
        <span class="s1">'password'</span> <span class="o">=&gt;</span> <span class="nf">env</span><span class="p">(</span><span class="s1">'REDIS_PASSWORD'</span><span class="p">,</span> <span class="kc">null</span><span class="p">),</span>
        <span class="s1">'port'</span> <span class="o">=&gt;</span> <span class="nf">env</span><span class="p">(</span><span class="s1">'REDIS_PORT'</span><span class="p">,</span> <span class="s1">'6379'</span><span class="p">),</span>
        <span class="s1">'database'</span> <span class="o">=&gt;</span> <span class="nf">env</span><span class="p">(</span><span class="s1">'REDIS_LOCK_DB'</span><span class="p">,</span> <span class="s1">'1'</span><span class="p">),</span> <span class="c1">// 예를 들어, 다른 DB 인덱스를 사용</span>
    <span class="p">],</span>
<span class="p">],</span>
</code></pre></div></div>

<p>이렇게 설정한 후, <code class="language-plaintext highlighter-rouge">Cache::store('redis')-&gt;lock(...)</code> 대신 <code class="language-plaintext highlighter-rouge">lockConnection</code>을 사용하여 <code class="language-plaintext highlighter-rouge">Cache::store('lockConnection')-&gt;lock(...)</code> 형식으로 분산 락을 구현할 수 있습니다.</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$lock</span> <span class="o">=</span> <span class="nc">Cache</span><span class="o">::</span><span class="nf">store</span><span class="p">(</span><span class="s1">'lockConnection'</span><span class="p">)</span><span class="o">-&gt;</span><span class="nf">lock</span><span class="p">(</span><span class="s1">'migration_tracker_insert'</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>

<span class="k">if</span> <span class="p">(</span><span class="nv">$lock</span><span class="o">-&gt;</span><span class="nf">get</span><span class="p">())</span> <span class="p">{</span>
    <span class="c1">// 락을 성공적으로 얻었을 때의 로직</span>
    <span class="c1">// ...</span>

    <span class="nv">$lock</span><span class="o">-&gt;</span><span class="nf">release</span><span class="p">();</span> <span class="c1">// 작업 완료 후 락 해제</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이 방식을 사용하면, 기본 캐시 데이터와 분산 락을 위한 데이터를 분리하여 관리할 수 있으며, 이는 경쟁 상태를 최소화하는데 도움이 될 수 있습니다. 분산 락을 위한 별도의 연결을 설정함으로써, 캐시 데이터와 락 데이터 간의 상호 작용이 서로 영향을 주지 않도록 할 수 있습니다.</p>]]></content><author><name></name></author><category term="Laravel" /><summary type="html"><![CDATA[개요 및 이슈]]></summary></entry><entry><title type="html">React Native, JSX</title><link href="https://binbyz.github.io//blog/react/native/2024/02/11/jsx.html" rel="alternate" type="text/html" title="React Native, JSX" /><published>2024-02-11T08:07:00+00:00</published><updated>2024-02-11T08:07:00+00:00</updated><id>https://binbyz.github.io//blog/react/native/2024/02/11/jsx</id><content type="html" xml:base="https://binbyz.github.io//blog/react/native/2024/02/11/jsx.html"><![CDATA[<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nx">TextInput</span>
  <span class="nx">value</span><span class="o">=</span><span class="p">{</span><span class="nx">text</span><span class="p">}</span>
  <span class="nx">style</span><span class="o">=</span><span class="p">{</span><span class="nx">styles</span><span class="p">.</span><span class="nx">input</span><span class="p">}</span>
  <span class="nx">placeholder</span><span class="o">=</span><span class="p">{</span><span class="nx">working</span> <span class="p">?</span> <span class="dl">'</span><span class="s1">Add a To Do</span><span class="dl">'</span> <span class="p">:</span> <span class="dl">'</span><span class="s1">Where do you want to go?</span><span class="dl">'</span><span class="p">}</span>
  <span class="nx">returnKeyType</span><span class="o">=</span><span class="dl">"</span><span class="s2">done</span><span class="dl">"</span>
  <span class="nx">secureTextEntry</span><span class="o">=</span><span class="p">{</span><span class="kc">false</span><span class="p">}</span>
  <span class="nx">multiline</span><span class="o">=</span><span class="p">{</span><span class="kc">false</span><span class="p">}</span>
  <span class="nx">placeholderTextColor</span><span class="o">=</span><span class="p">{</span><span class="nx">theme</span><span class="p">.</span><span class="nx">grey</span><span class="p">}</span>
  <span class="nx">onChangeText</span><span class="o">=</span><span class="p">{</span><span class="nx">onChangeText</span><span class="p">}</span>
  <span class="nx">onSubmitEditing</span><span class="o">=</span><span class="p">{</span><span class="nx">onSubmit</span><span class="p">}</span>
<span class="sr">/</span><span class="err">&gt;
</span></code></pre></div></div>

<p>갑자기 위의 코드를 보고 인지부조화가 왔습니다.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">value={text}</code> “여기서 brace(<code class="language-plaintext highlighter-rouge">{</code>, <code class="language-plaintext highlighter-rouge">}</code>)는 갑자기 왜 있는거지?”</li>
  <li>“함수의 본문을 작성할때 사용된 문법과 동일한가?”</li>
</ul>

<p>오랜만에 백엔드 개발을 하다가 자바스크립트 진영으로 넘어오면 가끔 이런 인지부조화가 옵니다.</p>

<h2 id="왜-valuetext로-작성하면-안되는가">왜 <code class="language-plaintext highlighter-rouge">value=text</code>로 작성하면 안되는가?</h2>

<p>JSX에서 속성을 지정할 때 <code class="language-plaintext highlighter-rouge">value=text</code>와 같이 작성하면, <code class="language-plaintext highlighter-rouge">text</code>를 문자열 리터럴로 인식하기 때문에 문제가 발생합니다. 자바스크립트의 표현식의 값을 속성에 전달하려면 <code class="language-plaintext highlighter-rouge">{}</code>를 사용해야 합니다. <code class="language-plaintext highlighter-rouge">{}</code> 안에 작성된 코드는 자바스크립트의 표현식으로 평가되고, 그 결과가 해당 속성의 값으로 사용됩니다. 따라서 <code class="language-plaintext highlighter-rouge">value={text}</code> 는 <code class="language-plaintext highlighter-rouge">text</code> 변수의 현재 값을 <code class="language-plaintext highlighter-rouge">value</code> 속성에 바인딩 하려면 필수적인 문법입니다.</p>

<h2 id="실제-컴파일된-자바스크립트-코드는-어떻게-되는가">실제 컴파일된 자바스크립트 코드는 어떻게 되는가?</h2>

<p>JSX 코드가 트랜스파일 과정을 거치면, React의 createElement 함수 호출로 변환된다. 예를 들어, JSX에서 다음과 같이 작성된 코드</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nx">TextInput</span> <span class="nx">value</span><span class="o">=</span><span class="p">{</span><span class="nx">text</span><span class="p">}</span> <span class="sr">/</span><span class="err">&gt;
</span></code></pre></div></div>

<p>트랜스파일 후의 자바스크립트 코드는 대략 다음과 같다.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">React</span><span class="p">.</span><span class="nf">createElement</span><span class="p">(</span><span class="nx">TextInput</span><span class="p">,</span> <span class="p">{</span> <span class="na">value</span><span class="p">:</span> <span class="nx">text</span> <span class="p">},</span> <span class="kc">null</span><span class="p">);</span>
</code></pre></div></div>

<p>이와 같이 JSX 문법을 사용하는 것은 React 요소를 생성하는 과정을 보다 선언적이고 직관적으로 만들어 주지만, 실제로는 <code class="language-plaintext highlighter-rouge">React.createElement</code> 함수 호출로 변환되어 JavaScript 엔진이 이해할 수 있는 코드로 실행됩니다. 따라서 JSX에서 <code class="language-plaintext highlighter-rouge">{}</code>를 사용하는 것은 JavaScript 표현식을 통해 <strong>동적인 값을 컴포넌트의 속성으로 전달</strong>할 수 있게 하는 중요한 문법적 기능입니다.</p>]]></content><author><name></name></author><category term="React" /><category term="Native" /><summary type="html"><![CDATA[&lt;TextInput value={text} style={styles.input} placeholder={working ? 'Add a To Do' : 'Where do you want to go?'} returnKeyType="done" secureTextEntry={false} multiline={false} placeholderTextColor={theme.grey} onChangeText={onChangeText} onSubmitEditing={onSubmit} /&gt;]]></summary></entry><entry><title type="html">React Native, Hook</title><link href="https://binbyz.github.io//blog/react/native/2024/02/11/react-native-beginner.html" rel="alternate" type="text/html" title="React Native, Hook" /><published>2024-02-11T06:24:00+00:00</published><updated>2024-02-11T06:24:00+00:00</updated><id>https://binbyz.github.io//blog/react/native/2024/02/11/react-native-beginner</id><content type="html" xml:base="https://binbyz.github.io//blog/react/native/2024/02/11/react-native-beginner.html"><![CDATA[<h2 id="react-native-hook-basic">React Native Hook Basic</h2>

<h3 id="useeffect">useEffect</h3>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">useEffect</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nf">loadTodos</span><span class="p">();</span>
<span class="p">},</span> <span class="p">[]);</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">useEffect</code> 훅을 사용하여 컴포넌트가 마운트될 때(즉, 화면에 처음으로 렌더링될 때) <code class="language-plaintext highlighter-rouge">loadToDos()</code> 함수를 실행한다.</li>
  <li>두 번째 인자는 의존성 배열로, 이 배열의 값에 따라 부수 효과의 실행 시점이 결정된다.
    <ul>
      <li>예를들어 <code class="language-plaintext highlighter-rouge">[todos]</code>와 같이 상태 변수를 배열에 포함시키면, <code class="language-plaintext highlighter-rouge">todos</code> 상태가 변경될 때마다 함수가 실행된다.</li>
      <li>하지만 여기서는 사용된 빈 배열이므로 컴포넌트가 마운트될 때만 함수를 실행하고, 그 이후에는 실행되지 않도록 함으로써 초기 데이터 로딩 같은 용도로 자주 사용된다.</li>
    </ul>
  </li>
</ul>

<h3 id="usestate">useState</h3>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="p">[</span><span class="nx">toDos</span><span class="p">,</span> <span class="nx">setToDos</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="o">&lt;</span><span class="nx">ToDo</span><span class="o">&gt;</span><span class="p">({});</span>
</code></pre></div></div>

<ul>
  <li>위의 <code class="language-plaintext highlighter-rouge">toDos</code>와 같은 <strong>상태 변수</strong>는 직접적으로 변경할 수 없는 <strong>불변(immutable)</strong> 상태로 취급된다.
    <ul>
      <li>React에서 상태 관리는 불변성을 유지하면서 이루어져야 한다. 이는 React가 효율적으로 UI를 업데이트할 수 있도록 돕는다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">setToDos</code>는 상태를 업데이트하는 함수이다.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">toDos</code>의 값을 직접 변경하는 것이 아니라, 상태를 업데이트할 필요가 있을 때는 항상 <code class="language-plaintext highlighter-rouge">setToDos</code> 함수를 사용하여 새로운 상태 값을 전달해야 한다. (React의 상태 불변성 원칙)</li>
    </ul>
  </li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 잘못된 예: 상태를 직접 변경</span>
<span class="nx">toDos</span><span class="p">.</span><span class="nx">key</span> <span class="o">=</span> <span class="nx">newValue</span><span class="p">;</span>

<span class="c1">// 올바른 예: 새로운 객체를 생성하여 상태 업데이트</span>
<span class="nf">setToDos</span><span class="p">({</span> <span class="na">key</span><span class="p">:</span> <span class="nx">newValue</span> <span class="p">});</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="React" /><category term="Native" /><summary type="html"><![CDATA[React Native Hook Basic]]></summary></entry><entry><title type="html">spatie/laravel-data 데이터 객체 복제</title><link href="https://binbyz.github.io//blog/laravel/2024/01/30/spatie-laravel-data-tips.html" rel="alternate" type="text/html" title="spatie/laravel-data 데이터 객체 복제" /><published>2024-01-30T04:12:00+00:00</published><updated>2024-01-30T04:12:00+00:00</updated><id>https://binbyz.github.io//blog/laravel/2024/01/30/spatie-laravel-data-tips</id><content type="html" xml:base="https://binbyz.github.io//blog/laravel/2024/01/30/spatie-laravel-data-tips.html"><![CDATA[<p>오픈소스 개발 회사 <strong>spatie</strong>에서 개발된 <a href="https://spatie.be/docs/laravel-data/v3/introduction">laravel-data</a> 패키지를 소개합니다. 공식 홈페이지에서는 다음과 같이 <strong>laravel-data</strong>를 소개하고 있습니다.</p>

<blockquote>
  <p>Powerful data objects for laravel</p>

  <p>… can be used in various ways. Using this package you only need to describe your data once:</p>

  <ul>
    <li>instead of a form request, you can use a data object</li>
    <li>instead of an API transformer, you can use a data object</li>
    <li>instead of manually writing a typescript definition, you can use… 🥁 a data object</li>
  </ul>
</blockquote>

<p>소개에서와 같이 해당 패키지를 통해 <code class="language-plaintext highlighter-rouge">Request</code> 객체를 만들고 <strong>validate</strong>도 같이 체크할 수 있고, <strong>transformer</strong>를 적용시킴으로써 쉽고 직관적으로 데이터를 변환할 수 있습니다.(여기서 말하는 transformer에 간단한 예시는 객채 클래스 내에서는 CamelCase 문법을 따르지만, API로 응답할 때는 snake_case로 변환하는 것을 말합니다.) 그리고 작성된 데이터 객체를 통해 <strong>typescript definition</strong>을 만들어 낼 수도 있습니다. 이 모든 것들은 PHP 8의 <strong>attributes</strong>를 통해 실행됩니다.</p>

<h2 id="설치">설치</h2>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>composer require spatie/laravel-data
</code></pre></div></div>

<h2 id="사용법">사용법</h2>

<p>그럼 <a href="https://spatie.be/docs/laravel-data/v3/introduction">spatie/laravel-data</a>를 통해 객체를 생성하는 방법에 대해 간단히 알아보겠습니다.</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?php</span>

<span class="kn">namespace</span> <span class="nn">App\Http\Controllers\Requests</span><span class="p">;</span>

<span class="kn">use</span> <span class="nc">Spatie\LaravelData\Data</span><span class="p">;</span>

<span class="kd">class</span> <span class="nc">FeedbackRequest</span> <span class="kd">extends</span> <span class="nc">Data</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">function</span> <span class="n">__construct</span><span class="p">(</span>
        <span class="k">public</span> <span class="k">readonly</span> <span class="kt">int</span> <span class="nv">$id</span><span class="p">,</span>
        <span class="k">public</span> <span class="k">readonly</span> <span class="kt">int</span> <span class="nv">$point</span><span class="p">,</span>
    <span class="p">)</span> <span class="p">{</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>기본적인 사용법은 위와 같습니다. <code class="language-plaintext highlighter-rouge">Spatie\LaravelData\Data</code> 객체를 상속하고, 속성들(<code class="language-plaintext highlighter-rouge">$id</code>, <code class="language-plaintext highlighter-rouge">$point</code>)을 정의해 줍니다. 그리고 객체를 생성할 때는 아래와 같이  <code class="language-plaintext highlighter-rouge">from</code> static 메소드를 통해 생성할 수 있습니다.</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$feedback</span> <span class="o">=</span> <span class="nc">FeedbackRequest</span><span class="o">::</span><span class="nf">from</span><span class="p">([</span>
    <span class="s1">'id'</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">,</span>
    <span class="s1">'point'</span> <span class="o">=&gt;</span> <span class="mi">5</span><span class="p">,</span>
<span class="p">]);</span>
</code></pre></div></div>

<p>그러면 <code class="language-plaintext highlighter-rouge">Spatie\LaravelData\Data</code> 객체를 가지고 라라벨의 <strong>Request</strong> 객체를 만들면서 <strong>validate</strong>를 처리하는 예시를 이어서 보겠습니다.</p>

<h3 id="request-객체-생성">Request 객체 생성</h3>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?php</span>

<span class="kn">namespace</span> <span class="nn">App\Http\Controllers\Requests</span><span class="p">;</span>

<span class="kn">use</span> <span class="nc">Spatie\LaravelData\Attributes\MapInputName</span><span class="p">;</span>
<span class="kn">use</span> <span class="nc">Spatie\LaravelData\Attributes\Validation\In</span><span class="p">;</span>
<span class="kn">use</span> <span class="nc">Spatie\LaravelData\Attributes\Validation\IntegerType</span><span class="p">;</span>
<span class="kn">use</span> <span class="nc">Spatie\LaravelData\Attributes\Validation\Required</span><span class="p">;</span>
<span class="kn">use</span> <span class="nc">Spatie\LaravelData\Data</span><span class="p">;</span>
<span class="kn">use</span> <span class="nc">Spatie\LaravelData\Mappers\SnakeCaseMapper</span><span class="p">;</span>

<span class="na">#[MapInputName(SnakeCaseMapper::class)]</span>
<span class="kd">class</span> <span class="nc">PointRequest</span> <span class="kd">extends</span> <span class="nc">Data</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">function</span> <span class="n">__construct</span><span class="p">(</span>
        <span class="na">#[Required, IntegerType]</span>
        <span class="k">public</span> <span class="k">readonly</span> <span class="kt">int</span> <span class="nv">$id</span><span class="p">,</span>

        <span class="na">#[Required, In([1, 2, 3])]</span>
        <span class="k">public</span> <span class="k">readonly</span> <span class="kt">int</span> <span class="nv">$point</span><span class="p">,</span>
    <span class="p">)</span> <span class="p">{</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>위의 <strong>Request</strong> 객체는 <code class="language-plaintext highlighter-rouge">#[MapInputName(SnakeCaseMapper::class)]</code> snake_case를 통해 파라메터를 매칭시키고, <code class="language-plaintext highlighter-rouge">#[Required, IntegerType]</code>을 통해 validate를 수행합니다. 모든 것들이 PHP 8의 <strong>attributes</strong>를 통해 실행됩니다. 정말 직관적이지 않나요? 위와 같이 작성된 클래스는 컨트롤러에서 다음과 같이 사용될 수 있습니다.</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?php</span>

<span class="kn">namespace</span> <span class="nn">App\Http\Controllers</span><span class="p">;</span>

<span class="kn">use</span> <span class="nc">App\Http\Controllers\Requests\PointRequest</span><span class="p">;</span>

<span class="k">readonly</span> <span class="kd">class</span> <span class="nc">PointController</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">function</span> <span class="n">incresePoint</span><span class="p">(</span><span class="kt">PointRequest</span> <span class="nv">$request</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="nv">$request</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>
        <span class="nv">$request</span><span class="o">-&gt;</span><span class="n">point</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>컨트롤러 레이어까지 들어오기 전에 이미 <strong>validate</strong>가 수행됩니다. 따라서 <strong>validate</strong>가 통과되지 못 하면 라라벨은 <strong>422 Unprocessable Entity</strong>를 반환합니다.</p>

<h3 id="dtodata-transfer-object-객체-생성">DTO(Data Transfer Object) 객체 생성</h3>

<p>DTO 객체로 사용할 수도 있습니다. 사용방법은 비슷합니다. 장점은 중첩된 클래스 형태를 가지고 있다면 <code class="language-plaintext highlighter-rouge">Data::from</code> 메소드를 통해 쉽게 생성할 수 있습니다. 아래의 예시를 보겠습니다.</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?php</span>

<span class="kn">namespace</span> <span class="nn">App\Services\Product\Dto</span><span class="p">;</span>

<span class="kn">use</span> <span class="nc">Carbon\Carbon</span><span class="p">;</span>
<span class="kn">use</span> <span class="nc">Spatie\LaravelData\Attributes\DataCollectionOf</span><span class="p">;</span>
<span class="kn">use</span> <span class="nc">Spatie\LaravelData\Attributes\MapOutputName</span><span class="p">;</span>
<span class="kn">use</span> <span class="nc">Spatie\LaravelData\Data</span><span class="p">;</span>
<span class="kn">use</span> <span class="nc">Spatie\LaravelData\DataCollection</span><span class="p">;</span>
<span class="kn">use</span> <span class="nc">Spatie\LaravelData\Mappers\SnakeCaseMapper</span><span class="p">;</span>

<span class="na">#[MapOutputName(SnakeCaseMapper::class)]</span>
<span class="kd">class</span> <span class="nc">BagDto</span> <span class="kd">extends</span> <span class="nc">Data</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">function</span> <span class="n">__construct</span><span class="p">(</span>
        <span class="k">public</span> <span class="k">readonly</span> <span class="kt">int</span> <span class="nv">$count</span><span class="p">,</span>

        <span class="na">#[DataCollectionOf(BagItemDto::class)]</span>
        <span class="k">public</span> <span class="k">readonly</span> <span class="kt">DataCollection</span> <span class="nv">$items</span><span class="p">,</span>
    <span class="p">)</span> <span class="p">{</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?php</span>

<span class="kn">namespace</span> <span class="nn">App\Services\Product\Dto</span><span class="p">;</span>

<span class="kn">use</span> <span class="nc">Spatie\LaravelData\Attributes\MapOutputName</span><span class="p">;</span>
<span class="kn">use</span> <span class="nc">Spatie\LaravelData\Data</span><span class="p">;</span>
<span class="kn">use</span> <span class="nc">Spatie\LaravelData\Mappers\SnakeCaseMapper</span><span class="p">;</span>

<span class="na">#[MapOutputName(SnakeCaseMapper::class)]</span>
<span class="kd">class</span> <span class="nc">BagItemDto</span> <span class="kd">extends</span> <span class="nc">Data</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">function</span> <span class="n">__construct</span><span class="p">(</span>
        <span class="k">public</span> <span class="k">readonly</span> <span class="kt">int</span> <span class="nv">$id</span><span class="p">,</span>
        <span class="k">public</span> <span class="k">readonly</span> <span class="kt">string</span> <span class="nv">$itemName</span><span class="p">,</span>
    <span class="p">)</span> <span class="p">{</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">BagDto</code>라는 가방은 갯수와 각 아이템들의 리스트를 가지고 있습니다. 이를 객체로 생성하려면 아래와 같이 <code class="language-plaintext highlighter-rouge">items</code>에 배열 형태로 넘기거나 라라벨의 <code class="language-plaintext highlighter-rouge">Collection</code>에 담아 넘길 수 있습니다.</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$items</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">[</span><span class="s1">'id'</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">'itemName'</span> <span class="o">=&gt;</span> <span class="s1">'item1'</span><span class="p">],</span>
    <span class="p">[</span><span class="s1">'id'</span> <span class="o">=&gt;</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">'itemName'</span> <span class="o">=&gt;</span> <span class="s1">'item2'</span><span class="p">],</span>
<span class="p">];</span>

<span class="nv">$bag</span> <span class="o">=</span> <span class="nc">BagDto</span><span class="o">::</span><span class="nf">from</span><span class="p">([</span>
    <span class="s1">'count'</span> <span class="o">=&gt;</span> <span class="mi">2</span><span class="p">,</span>
    <span class="s1">'items'</span> <span class="o">=&gt;</span> <span class="nv">$items</span><span class="p">,</span>
<span class="p">]);</span>

<span class="nv">$bag</span> <span class="o">=</span> <span class="nc">BagDto</span><span class="o">::</span><span class="nf">from</span><span class="p">([</span>
    <span class="s1">'count'</span> <span class="o">=&gt;</span> <span class="mi">2</span><span class="p">,</span>
    <span class="s1">'items'</span> <span class="o">=&gt;</span> <span class="nf">collect</span><span class="p">(</span><span class="nv">$items</span><span class="p">),</span>
<span class="p">]);</span>
</code></pre></div></div>

<p>또 한, <code class="language-plaintext highlighter-rouge">#[MapOutputName(SnakeCaseMapper::class)]</code>를 통해 snake_case로 변환된 데이터를 반환할 수 있습니다. 실제 API 상에서 응답된 데이터 포맷은 다음과 같습니다. <code class="language-plaintext highlighter-rouge">$itemName</code> 속성이 snake_case 포맷으로 변환되어 출력됩니다.</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
    <span class="s2">"count"</span><span class="o">:</span> <span class="mi">2</span><span class="p">,</span>
    <span class="s2">"items"</span><span class="o">:</span> <span class="p">[</span>
        <span class="p">{</span>
            <span class="s2">"id"</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
            <span class="s2">"item_name"</span><span class="o">:</span> <span class="s2">"item1"</span>
        <span class="p">},</span>
        <span class="p">{</span>
            <span class="s2">"id"</span><span class="o">:</span> <span class="mi">2</span><span class="p">,</span>
            <span class="s2">"item_name"</span><span class="o">:</span> <span class="s2">"item2"</span>
        <span class="p">}</span>
    <span class="p">]</span>
<span class="p">}</span>
</code></pre></div></div>

<p>위에 예시들은 라라벨의 기본적인 기능을 통해 이미 구현 가능한 부분이지만 <code class="language-plaintext highlighter-rouge">spatie/laravel-data</code> 패키지를 통해 더 직관적이고 조금 더 클래스 친화적으로 코드를 유지할 수 있습니다. 또한, <code class="language-plaintext highlighter-rouge">spatie/laravel-data</code> 패키지를 통해 <strong>typescript definition</strong>을 생성할 수 있습니다.</p>

<h3 id="typescript-definition-생성">Typescript Definition 생성</h3>

<p>이미 우리는 DTO 예시에서 <code class="language-plaintext highlighter-rouge">BagDto</code>와 <code class="language-plaintext highlighter-rouge">BagItemDto</code>를 만들었습니다. 여기에 추가적인 <strong>Attributes</strong> 작성을 통해 쉽게 <strong>typescript definition</strong>을 생성할 수 있습니다. 이를 실행하면 추가적인 패키지가 요구됩니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>composer require spatie/laravel-typescript-transformer
</code></pre></div></div>

<p>해당 패키지의 자세한 사용법은 추후 다른 게시글을 통해 자세히 더 살펴보도록 하겠습니다. 공식 문서를 통해 이미 자세한 내용이 설명되어 있으므로 공식 문서를 참고해도 됩니다. <a href="https://spatie.be/docs/typescript-transformer/v2/introduction">spatie/laravel-typescript-transformer</a></p>

<p>해당 패키지의 생산성은 DTO를 통해 잘 구성된 API 리소스들을 클라이언트 개발자와 함께 협업하기에 용이합니다. 어디까지나 선택사항입니다.</p>

<h3 id="심화편-객체-복제하기">심화편: 객체 복제하기</h3>

<p>생성된 DTO 객체를 일부 값만 변경하고 싶을 때가 있습니다. 여기서는 <code class="language-plaintext highlighter-rouge">BadItemDto</code>의 <code class="language-plaintext highlighter-rouge">$id</code> 값은 유지하면서 <code class="language-plaintext highlighter-rouge">$itemName</code>만 변경하고 싶을 때를 가정해 보겠습니다.</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">#[MapOutputName(SnakeCaseMapper::class)]</span>
<span class="kd">class</span> <span class="nc">BagItemDto</span> <span class="kd">extends</span> <span class="nc">Data</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">function</span> <span class="n">__construct</span><span class="p">(</span>
        <span class="k">public</span> <span class="k">readonly</span> <span class="kt">int</span> <span class="nv">$id</span><span class="p">,</span>
        <span class="k">public</span> <span class="k">readonly</span> <span class="kt">string</span> <span class="nv">$itemName</span><span class="p">,</span>
    <span class="p">)</span> <span class="p">{</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">function</span> <span class="n">withItemName</span><span class="p">(</span><span class="kt">string</span> <span class="nv">$itemName</span><span class="p">):</span> <span class="kt">self</span>
    <span class="p">{</span>
        <span class="c1">// array 형태로 변환</span>
        <span class="nv">$bagItem</span> <span class="o">=</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="nf">transform</span><span class="p">(</span><span class="n">transformValues</span><span class="o">:</span> <span class="kc">false</span><span class="p">,</span> <span class="n">mapPropertyNames</span><span class="o">:</span> <span class="kc">false</span><span class="p">);</span>

        <span class="nv">$bagItem</span><span class="p">[</span><span class="s1">'itemName'</span><span class="p">]</span> <span class="o">=</span> <span class="nv">$itemName</span><span class="p">;</span>

        <span class="k">return</span> <span class="k">self</span><span class="o">::</span><span class="nf">from</span><span class="p">(</span><span class="nv">$bagItem</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>해당 예제에서는 <code class="language-plaintext highlighter-rouge">#[MapOutputName(SnakeCaseMapper::class)]</code>를 통해 snake_case로 변환된 데이터를 반환하고 있습니다. 해당 부분이 없다면 간편하게 <code class="language-plaintext highlighter-rouge">$this-&gt;with()</code> 메소드를 통해 원본 데이터를 연관 배열로 리턴 받을 수 있지만, snake_case로 변환 규칙이 작성돼 있으므로 <code class="language-plaintext highlighter-rouge">$this-&gt;transform(transformValues: false, mapPropertyNames: false)</code>를 통해 연관 배열로 변환합니다. 그리고 연관 배열로 변환된 데이터를 통해 원하는 값을 변경하고 <code class="language-plaintext highlighter-rouge">self::from($bagItem)</code>를 통해 객체를 생성합니다.</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$bagItem</span> <span class="o">=</span> <span class="nc">BagItemDto</span><span class="o">::</span><span class="nf">from</span><span class="p">([</span>
    <span class="s1">'id'</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">,</span>
    <span class="s1">'itemName'</span> <span class="o">=&gt;</span> <span class="s1">'item1'</span><span class="p">,</span>
<span class="p">]);</span>

<span class="nv">$bagItem</span><span class="o">-&gt;</span><span class="nf">withItemName</span><span class="p">(</span><span class="s1">'item2'</span><span class="p">);</span>
</code></pre></div></div>

<h2 id="마치며">마치며</h2>

<p>어디까지나 라이브러리를 채택하고 사용하고는 선택사항입니다. 라라벨을 경험하신지 얼마 되지 않으셨으면 라라벨 본래의 기능을 한 번 접하시고 라이브러리를 사용하시길 권장합니다. 그리고 위의 작성된 방법과 비교하고 어떤 부분이 우리 팀에 더 적합한 방법이 될지 고민해 보시길 바랍니다.</p>]]></content><author><name></name></author><category term="Laravel" /><summary type="html"><![CDATA[오픈소스 개발 회사 spatie에서 개발된 laravel-data 패키지를 소개합니다. 공식 홈페이지에서는 다음과 같이 laravel-data를 소개하고 있습니다.]]></summary></entry></feed>